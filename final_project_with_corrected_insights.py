# -*- coding: utf-8 -*-
"""final_project_with_corrected_insights.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1JmQtqWRovJQ-3QLrZuNZCejEXkCigGKI

# Cryptocurrency Price Prediction Project (Expanded)

This notebook analyzes and predicts cryptocurrency prices for multiple cryptocurrencies using both historical and real-time data.
It now includes advanced machine learning techniques and support for comparing multiple models.

### Key Features:
1. **Dynamic Data Fetching**:
   - Fetch data for multiple cryptocurrencies using the CoinGecko API.
2. **Comparative Model Evaluation**:
   - Compare different models (e.g., Random Forest, XGBoost, LSTM) for prediction accuracy.
3. **Visualization Enhancements**:
   - Interactive visualizations using Plotly.
4. **Feature Expansion**:
   - Includes new features like moving averages and percentage changes.

### Supported Cryptocurrencies:
- Bitcoin (BTC)
- Ethereum (ETH)
- Cardano (ADA)

---
**Goal**: Enhance prediction accuracy while providing insights across multiple cryptocurrencies.
"""

# Commented out IPython magic to ensure Python compatibility.

# Import required libraries
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.express as px
import requests
from datetime import datetime
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.metrics import mean_squared_error, mean_absolute_error
from xgboost import XGBRegressor

# Ensure plots are displayed inline
# %matplotlib inline

# Function to fetch real-time cryptocurrency data for multiple coins
def fetch_crypto_data(cryptos, currency='usd', days=30, interval='daily'):
    all_data = {}
    for crypto in cryptos:
        url = f"https://api.coingecko.com/api/v3/coins/{crypto}/market_chart"
        params = {'vs_currency': currency, 'days': days, 'interval': interval}
        response = requests.get(url, params=params)
        if response.status_code == 200:
            data = response.json()
            prices = data['prices']
            df = pd.DataFrame(prices, columns=['timestamp', 'price'])
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            df.rename(columns={'timestamp': 'Date', 'price': f'{crypto}_Close'}, inplace=True)
            all_data[crypto] = df
            print(f"Data fetched successfully for {crypto}! Shape: {df.shape}")
        else:
            print(f"Failed to fetch data for {crypto}: {response.status_code}")
    return all_data

# Fetch data for Bitcoin, Ethereum, and Cardano
cryptos = ['bitcoin', 'ethereum', 'cardano']
crypto_data = fetch_crypto_data(cryptos, days=30)

# Combine data into a single DataFrame
combined_data = pd.DataFrame()
for crypto, df in crypto_data.items():
    if combined_data.empty:
        combined_data = df
    else:
        combined_data = pd.merge(combined_data, df, on='Date', how='outer')

# Display the combined data
if not combined_data.empty:
    display(combined_data.head())

# Exploratory Data Analysis (EDA)
if not combined_data.empty:
    print("Dataset Info:")
    combined_data.info()
    print("\nSummary Statistics:")
    display(combined_data.describe())

    # Interactive Plotly Visualization
    fig = px.line(combined_data, x='Date', y=[f'{crypto}_Close' for crypto in cryptos],
                  title="Cryptocurrency Prices Over Time",
                  labels={'value': 'Price (USD)', 'variable': 'Cryptocurrency'})
    fig.show()
else:
    print("No data available for analysis.")

# Comparative Model Evaluation
if not combined_data.empty:
    # Use Bitcoin as an example target
    combined_data['Day'] = np.arange(len(combined_data))
    X = combined_data[['Day']].fillna(0)
    results = {}

    for crypto in cryptos:
        if f'{crypto}_Close' in combined_data.columns:
            y = combined_data[f'{crypto}_Close'].fillna(0)

            # Train-test split
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

            # Models to compare
            models = {
                'Random Forest': RandomForestRegressor(n_estimators=100, random_state=42),
                'XGBoost': XGBRegressor(n_estimators=100, random_state=42)
            }

            # Evaluate each model
            for model_name, model in models.items():
                model.fit(X_train, y_train)
                y_pred = model.predict(X_test)

                # Metrics
                mse = mean_squared_error(y_test, y_pred)
                mae = mean_absolute_error(y_test, y_pred)
                print(f"{model_name} - {crypto}: MSE={mse:.2f}, MAE={mae:.2f}")

                # Save results
                results[f'{crypto}_{model_name}'] = {'MSE': mse, 'MAE': mae}
else:
    print("No data available for model evaluation.")

# Add Moving Averages, Percent Changes, and RSI
def add_technical_features(data, close_column):
    data['MA_10'] = data[close_column].rolling(window=10).mean()  # 10-day Moving Average
    data['MA_20'] = data[close_column].rolling(window=20).mean()  # 20-day Moving Average
    data['Pct_Change'] = data[close_column].pct_change() * 100  # Percentage Change
    data['RSI'] = calculate_rsi(data[close_column], window=14)  # RSI (14-day)
    return data

# RSI Calculation
def calculate_rsi(series, window):
    delta = series.diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=window).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=window).mean()
    rs = gain / loss
    return 100 - (100 / (1 + rs))

# Apply the technical features to the dataset
if 'combined_data' in locals() and not combined_data.empty:
    for crypto in cryptos:
        close_column = f'{crypto}_Close'
        if close_column in combined_data.columns:
            combined_data = add_technical_features(combined_data, close_column)
    display(combined_data.head())
else:
    print("No data available to compute technical indicators.")

import numpy as np
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout

# Prepare data for LSTM
def prepare_lstm_data(data, target_column, look_back=10):
    values = data[target_column].fillna(0).values.reshape(-1, 1)
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_values = scaler.fit_transform(values)

    X, y = [], []
    for i in range(look_back, len(scaled_values)):
        X.append(scaled_values[i - look_back:i, 0])
        y.append(scaled_values[i, 0])

    return np.array(X), np.array(y), scaler

if not combined_data.empty:
    # Example: Prepare data for Bitcoin
    target_column = 'bitcoin_Close'
    look_back = 10
    if target_column in combined_data.columns:
        X_lstm, y_lstm, scaler = prepare_lstm_data(combined_data, target_column, look_back)
        X_lstm = X_lstm.reshape((X_lstm.shape[0], X_lstm.shape[1], 1))  # Reshape for LSTM input
        print(f"LSTM data prepared. X shape: {X_lstm.shape}, y shape: {y_lstm.shape}")
else:
    print("No data available for LSTM preparation.")

# Train LSTM Model
if 'X_lstm' in locals() and X_lstm.size > 0:
    # Split data into train and test sets
    split_index = int(len(X_lstm) * 0.8)
    X_train, X_test = X_lstm[:split_index], X_lstm[split_index:]
    y_train, y_test = y_lstm[:split_index], y_lstm[split_index:]

    # Build LSTM model
    model = Sequential()
    model.add(LSTM(50, return_sequences=True, input_shape=(X_train.shape[1], 1)))
    model.add(Dropout(0.2))
    model.add(LSTM(50, return_sequences=False))
    model.add(Dropout(0.2))
    model.add(Dense(1))

    # Compile and train the model
    model.compile(optimizer='adam', loss='mean_squared_error')
    model.fit(X_train, y_train, epochs=20, batch_size=32, validation_data=(X_test, y_test), verbose=1)

    # Make predictions
    y_pred_lstm = model.predict(X_test)
    y_pred_lstm_rescaled = scaler.inverse_transform(y_pred_lstm)
    y_test_rescaled = scaler.inverse_transform(y_test.reshape(-1, 1))

    # Plot predictions vs actual
    plt.figure(figsize=(10, 5))
    plt.plot(y_test_rescaled, label='Actual', color='blue')
    plt.plot(y_pred_lstm_rescaled, label='Predicted', color='orange')
    plt.title("LSTM Predictions vs Actual Prices")
    plt.legend()
    plt.grid()
    plt.show()
else:
    print("LSTM data not available for training.")

# Compare models
if not combined_data.empty:
    results = {}

    for crypto in cryptos:
        target_column = f'{crypto}_Close'
        if target_column in combined_data.columns:
            # Prepare data
            combined_data['Day'] = np.arange(len(combined_data))
            X = combined_data[['Day']].fillna(0)
            y = combined_data[target_column].fillna(0)
            X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

            # Random Forest
            rf_model = RandomForestRegressor(n_estimators=100, random_state=42)
            rf_model.fit(X_train, y_train)
            y_pred_rf = rf_model.predict(X_test)
            mse_rf = mean_squared_error(y_test, y_pred_rf)
            mae_rf = mean_absolute_error(y_test, y_pred_rf)

            # XGBoost
            xgb_model = XGBRegressor(n_estimators=100, random_state=42)
            xgb_model.fit(X_train, y_train)
            y_pred_xgb = xgb_model.predict(X_test)
            mse_xgb = mean_squared_error(y_test, y_pred_xgb)
            mae_xgb = mean_absolute_error(y_test, y_pred_xgb)

            # Store results
            results[crypto] = {
                'Random Forest': {'MSE': mse_rf, 'MAE': mae_rf},
                'XGBoost': {'MSE': mse_xgb, 'MAE': mae_xgb}
            }

    # Display results
    for crypto, metrics in results.items():
        print(f"--- {crypto.upper()} ---")
        for model, scores in metrics.items():
            print(f"{model}: MSE={scores['MSE']:.2f}, MAE={scores['MAE']:.2f}")
else:
    print("No data available for model comparison.")

from datetime import datetime

# Real-time insights based on the last available predictions
def generate_insights(predictions, actuals, crypto_name):
    today = datetime.now().strftime('%Y-%m-%d')
    last_pred = predictions[-1] if len(predictions) > 0 else None
    last_actual = actuals[-1] if len(actuals) > 0 else None
    if last_pred and last_actual:
        change = ((last_pred - last_actual) / last_actual) * 100
        print(f"Real-Time Insights for {crypto_name} on {today}:")
        print(f"  - Last Predicted Price: ${last_pred:.2f}")
        print(f"  - Last Actual Price: ${last_actual:.2f}")
        print(f"  - Predicted Change: {change:.2f}%")
    else:
        print(f"No predictions or actual values available for {crypto_name}.")

if 'y_pred_lstm_rescaled' in locals() and 'y_test_rescaled' in locals():
    # Example: Generate insights for Bitcoin
    generate_insights(y_pred_lstm_rescaled.flatten(), y_test_rescaled.flatten(), "Bitcoin")
else:
    print("Real-time insights could not be generated due to missing data.")

"""
# Real-Time Insights

This section generates predictions and insights for the current day based on the last available data.
Insights include:
- Predicted prices for each cryptocurrency.
- Actual prices from the test dataset (if available).
- Percentage change between predicted and actual values.

These insights are provided for the day when the notebook is executed.
    """

# Generate real-time insights for multiple cryptocurrencies
from datetime import datetime

def ensure_array(data):
    # Ensure the data is a NumPy array
    if isinstance(data, pd.Series):
        return data.to_numpy()
    elif isinstance(data, np.ndarray):
        return data
    else:
        raise ValueError("Unsupported data type. Expected pandas.Series or numpy.ndarray.")

def generate_multi_crypto_insights(predictions_dict, actuals_dict, cryptos, scaler_dict):
    today = datetime.now().strftime('%Y-%m-%d')
    print(f"--- Real-Time Insights for {today} ---\n")
    for crypto in cryptos:
        if crypto in predictions_dict and crypto in actuals_dict and crypto in scaler_dict:
            predictions = ensure_array(predictions_dict[crypto]).flatten()
            actuals = ensure_array(actuals_dict[crypto]).flatten()
            if len(predictions) > 0 and len(actuals) > 0:
                last_pred = scaler_dict[crypto].inverse_transform([[predictions[-1]]])[0][0]
                last_actual = scaler_dict[crypto].inverse_transform([[actuals[-1]]])[0][0]
                change = ((last_pred - last_actual) / last_actual) * 100 if last_actual != 0 else 0
                print(f"Insights for {crypto.capitalize()}:")
                print(f"  - Predicted Price: ${last_pred:.2f}")
                print(f"  - Actual Price: ${last_actual:.2f}")
                print(f"  - Predicted Change: {change:.2f}%\n")
            else:
                print(f"No valid data available for {crypto.capitalize()}\n")
        else:
            print(f"Data missing for {crypto.capitalize()}\n")

# Example: Placeholder predictions and actuals for multiple cryptocurrencies
predictions_dict = {'bitcoin': y_pred_lstm, 'ethereum': y_pred_lstm, 'cardano': y_pred_lstm}  # Replace with actual predictions
actuals_dict = {'bitcoin': y_test, 'ethereum': y_test, 'cardano': y_test}  # Replace with actual values
scaler_dict = {'bitcoin': scaler, 'ethereum': scaler, 'cardano': scaler}  # Replace with actual scalers

if 'y_pred_lstm' in locals() and 'y_test' in locals():
    generate_multi_crypto_insights(predictions_dict, actuals_dict, cryptos, scaler_dict)
else:
    print("Real-time insights could not be generated due to missing data.")